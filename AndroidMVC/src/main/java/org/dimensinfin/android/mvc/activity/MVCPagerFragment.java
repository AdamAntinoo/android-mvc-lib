package org.dimensinfin.android.mvc.activity;

import android.content.Context;
import android.os.Bundle;
import android.view.ContextMenu;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.ListView;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import java.util.List;
import java.util.Objects;

import org.dimensinfin.android.mvc.R;
import org.dimensinfin.android.mvc.controller.AndroidController;
import org.dimensinfin.android.mvc.core.IAndroidController;
import org.dimensinfin.android.mvc.core.IDataSource;
import org.dimensinfin.android.mvc.core.MVCScheduler;
import org.dimensinfin.android.mvc.datasource.DataSourceAdapter;
import org.dimensinfin.android.mvc.datasource.DataSourceManager;
import org.dimensinfin.android.mvc.datasource.HeaderDataSourceAdapter;
import org.dimensinfin.android.mvc.exception.ExceptionRenderGenerator;
import org.dimensinfin.android.mvc.exception.ExceptionToExceptionReportConverter;
import org.dimensinfin.android.mvc.interfaces.IMenuActionTarget;
import org.dimensinfin.android.mvc.ui.HeaderListLayout;
import org.dimensinfin.logging.LogWrapper;

/**
 * @author Adam Antinoo
 * @since 1.0.0
 */
public abstract class MVCPagerFragment extends MVCFragment {
	/**
	 * This is the reference to the root view generated by the inflation of the fragment's layout.
	 */
	protected ViewGroup _container;

	// - U I    F I E L D S
	/**
	 * The view that handles the non scrolling header. It accepts a list of Views but has no scroll capabilities.
	 */
	protected HeaderListLayout headerContainer;
	/** The adapter to transform the model list to the view contents for the header section or a page. */
	private HeaderDataSourceAdapter headerSectionAdapter;
	/** The view that represent the list view and the space managed though the adapter. */
	private ListView dataSectionContainer;
	/**
	 * Evolved adapter to connect the source of data in the form of a <b>AndroidController</b> list to the
	 * <code>ListView</code> that contains the displayed render.
	 */
	private DataSourceAdapter dataAdapter;
//	/**
//	 * The UI graphical element that defines the loading progress spinner layout.
//	 */
//	@Deprecated
//	private ViewGroup _progressLayout;
//	/**
//	 * This is a text field defined inside the loading progress spinner that will show the time elapsed waiting for the
//	 * completion of the loading process.
//	 */
//	@Deprecated
//	private TextView _progressElapsedCounter;

	// - A C C E P T A N C E
	public HeaderListLayout accessHeaderContainer() {
		return this.headerContainer;
	}

	public List<IAndroidController> accessHeaderContents() {
		return this.headerSectionAdapter.accessContents();
	}

	public ListView accessDataSectionContainer() {
		return this.dataSectionContainer;
	}

	public List<IAndroidController> accessDataContents() {
		return this.dataAdapter.accessContents();
	}

	public void updateDisplay() {
		this.dataSectionContainer.invalidate();
		this.headerContainer.invalidate();
		this.dataAdapter.notifyDataSetChanged();
		this.headerSectionAdapter.notifyDataSetChanged();
	}

	// - F R A G M E N T   L I F E C Y C L E

	@Nullable
	@Override
	public Context getContext() {
		return this.getActivityContext();
	}

	/**
	 * During the creation process we connect the local fields to the UI graphical objects defined by the layout. We use a
	 * generic layout that defines the two items that compose all the displays for the MVC fragments. The <b>Header</b>
	 * ViewGroup container, the <b>Data Section</b> implemented by a ListView and the loading progress indicator that will
	 * be present on the DataSection display are while the model is generated and transformed into the View list. At that
	 * point the progress will be removed to show the view list for this time instant model.
	 *
	 * The method has two sections. The first section will find and reference the ui graphical elements where to render
	 * the data while the second section will instantiate and initialize the application specific code to generate the
	 * models for this fragment instance.
	 *
	 * @param inflater           <code>LayoutInflater</code> received from the context to create the layout from the XML
	 *                           definition file.
	 * @param container          container where this layout is displayed.
	 * @param savedInstanceState if we are recovering the layout from a task switch this is the previous saved state of
	 *                           the fragment when the application was switched out of focus.
	 * @return the view that represents the fragment ui layout structure.
	 */
	@Override
	public View onCreateView( @NonNull final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState ) {
		LogWrapper.enter();
		super.onCreateView( inflater, container, savedInstanceState );
		// TODO analyze what is returned by the savedInstanceState when recovering the application. That will help to recover the
		// functional state of the application.
		// - S E C T I O N   1. Where we get access to the UI elements.
		LogWrapper.info( "SECTION 1. UI linking." );
		try {
			this._container = Objects.requireNonNull( (ViewGroup) inflater.inflate( R.layout.fragment_base, container, false ) );
			this.dataSectionContainer = Objects.requireNonNull( this._container.findViewById( R.id.dataContainer ) );
			this.headerContainer = Objects.requireNonNull( this._container.findViewById( R.id.headerContainer ) );
			// TODO - Remove this and replace by an spinner at the header.
//			this._progressLayout = Objects.requireNonNull( this._container.findViewById( R.id.progressLayout ) );
//			this._progressElapsedCounter = Objects.requireNonNull( this._container.findViewById( R.id.progressCounter ) );
		} catch (final NullPointerException npe) {
			// The view is not properly created because the layout does not match or there is a unrecoverable error.
			LogWrapper.error( npe );
			this.lastException = npe;
			this.showException( npe ); // Show any exception data on the empty page.
			return container;
		}
		// Set the visual state of all items.
//		_progressLayout.setVisibility( View.INVISIBLE );
		this.headerContainer.setVisibility( View.VISIBLE );
		this.dataSectionContainer.setVisibility( View.VISIBLE );
//		_progressElapsedCounter.setVisibility( View.INVISIBLE );
		// Prepare the structures for the context menu.
		// TODO Check if the menus can be tied to the Parts independently and not to the whole Header.
		//			this.registerForContextMenu(_headerContainer);
		this.registerForContextMenu( dataSectionContainer );

		// - S E C T I O N   2. Where we setup the data sources for the adapters. Only include no long time operations.
		LogWrapper.info( "SECTION 2. Adapters and data sources creation and connection." );
		try {
			// Install the adapter before any data request or model generation.
			final IDataSource ds = DataSourceManager.registerDataSource( Objects.requireNonNull( this.createDS() ) );
			this.dataAdapter = Objects.requireNonNull( new DataSourceAdapter( this, ds ) );
			LogWrapper.info( "Adapter set: {}", this.dataAdapter.toString() );
			this.dataSectionContainer.setAdapter( this.dataAdapter );
			this.headerSectionAdapter = Objects.requireNonNull( new HeaderDataSourceAdapter( this, ds ) );
			this.headerContainer.setAdapter( this.headerSectionAdapter );
		} catch (final RuntimeException rtex) {
			LogWrapper.error( rtex );
			this.lastException = rtex;
			this.showException( rtex ); // Show any exception data on the empty page.
		} finally {
			LogWrapper.exit();
		}
		return _container;
	}

	@Override
	public void onViewStateRestored( Bundle savedInstanceState ) {
		// Restore the variant name.
		if (null != savedInstanceState)
			this.setVariant( savedInstanceState.getString( MVCMultiPageActivity.EMVCExtras.EXTRA_VARIANT.name() ) );
		super.onViewStateRestored( savedInstanceState );
	}

	/**
	 * At this point on the Fragment life cycle we are sure that the fragment is already constructed and that the flow is
	 * ready to get and process the model data. The model data is going to be feed directly to the rendering layout while
	 * it is being generated so the experience is more close to real time data presentation. Instead waiting for all the
	 * model generation and model transformation processed to complete we will be streaming the data since the first
	 * moment we have something to show.
	 *
	 * Because the model generation is running on a background thread we should synchronize to the model generation termination before invalidating
	 * the views and forcing the rendering. At the same time this should remove the spinner and show the list views. So even the task to be run is
	 * on the UI thread we should encapsulate that on a new background job to be posted after the current model generation job.
	 */
	@Override
	public void onStart() {
		LogWrapper.enter();
		super.onStart();
		try {
			if (null != this.dataAdapter) { // Check that view creation completed successfully.
				// - S E C T I O N   3. Post the task to generate the header and the data contents to be rendered.
				MVCScheduler.backgroundExecutor.submit( () -> {
					LogWrapper.info( "SECTION 3. Model Initialization" );
					this.headerSectionAdapter.clean(); // Clear the contents from the previous spinner
					this.dataAdapter.requestDataModel(); // Call the ds to generate the root contents.
				} );

				// - S E C T I O N   4. Post to the thread runner another task to be done after all data is generated
				// We use another thread to perform the data source generation that is a long time action.
				MVCScheduler.backgroundExecutor.submit( () -> {
					LogWrapper.info( "SECTION 4. Display redraw." );
					this.getActivityContext().runOnUiThread( () -> {
//						this.hideProgressIndicator(); // Hide the waiting indicator after the model is generated and the view populated.
						this.updateDisplay();
					} );
				} );
			}
		} catch (final RuntimeException rtex) {
			LogWrapper.error( rtex );
			this.lastException = rtex;
			this.showException( rtex ); // Show any exception data on the empty page.
		}
		LogWrapper.exit();
	}

	@Override
	public void onSaveInstanceState( final Bundle outState ) {
		super.onSaveInstanceState( outState );
		// Save the variant assigned to this fragment instance.
		outState.putString( MVCMultiPageActivity.EMVCExtras.EXTRA_VARIANT.name(), getVariant() );
	}

	@Override
	public void onCreateContextMenu( final ContextMenu menu, final View view, final ContextMenu.ContextMenuInfo menuInfo ) {
		logger.info( ">> [MVCPagerFragment.onCreateContextMenu]" );
		// REFACTOR If we call the super then the fragment's parent context gets called. So the listcallback and the Activity
		// have not to be the same
		//			super.onCreateContextMenu(menu, view, menuInfo);
		// Check parameters to detect the item selected for menu target.
		//		if (view == _headerContainer) {
		//			// Check if this fragment has the callback configured
		//			final IAndroidAndroidController part = _headerContents.firstElement();
		//			if (part instanceof IMenuActionTarget) {
		//				((IMenuActionTarget) part).onCreateContextMenu(menu, view, menuInfo);
		//			}
		//		}
		//		if (view == _dataSectionContainer) {
		// Now header and data section ave the same functionality.
		// Get the tag assigned to the selected view and if implements the callback interface send it the message.
		final AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) menuInfo;
		// Check if the selected item is suitable for menu and select it depending on item part class.
		AndroidController part = (AndroidController) info.targetView.getTag();
		if (part instanceof IMenuActionTarget) {
			((IMenuActionTarget) part).onCreateContextMenu( menu, view, menuInfo );
		}
		//		}
		logger.info( "<< [MVCPagerFragment.onCreateContextMenu]" ); //$NON-NLS-1$
	}

	// - CONTEXTUAL MENU FOR THE HEADER
	@Override
	public boolean onContextItemSelected( final MenuItem item ) {
		logger.info( ">> ManufactureContextFragment.onContextItemSelected" );
		final AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
		final int menuItemIndex = item.getItemId();
		final AndroidController part = (AndroidController) info.targetView.getTag();
		if (part instanceof IMenuActionTarget)
			return ((IMenuActionTarget) part).onContextItemSelected( item );
		else
			return true;
	}

	// - H E A D E R   M A N A G E M E N T   S E C T I O N

	protected void showException( final Exception exception ) {
		// Hide standard elements.
		this.headerContainer.setVisibility( View.GONE );
		this.dataSectionContainer.setVisibility( View.GONE );
		final ViewGroup exceptionContainer = _container.findViewById( R.id.exceptionContainer );
		exceptionContainer.removeAllViews();
		exceptionContainer.addView( new ExceptionRenderGenerator.Builder()
				                            .withContext( this.getContext() )
				                            .withFactory( this.getFactory() )
				                            .withExceptionReport( new ExceptionToExceptionReportConverter().convert( exception ) )
				                            .build().getView() );
		exceptionContainer.setVisibility( View.VISIBLE );
	}

//	@Deprecated
//	private void hideProgressIndicator() {
//		_progressLayout.setVisibility( View.GONE );
//		dataSectionContainer.setVisibility( View.VISIBLE );
//		_progressElapsedCounter.setVisibility( View.GONE );
//	}

	// - U T I L I T I E S
//	private void initializeProgressIndicator() {
//		_progressElapsedCounter = Objects.requireNonNull( _container.findViewById( R.id.progressCounter ) );
//		final Instant _elapsedTimer = Instant.now();
//		new CountDownTimer( TimeUnit.DAYS.toMillis( 1 ), TimeUnit.MILLISECONDS.toMillis( 10 ) ) {
//			@Override
//			public void onTick( final long millisUntilFinished ) {
//				_progressElapsedCounter.setText( generateTimeString( _elapsedTimer.getMillis() ) );
//				_progressElapsedCounter.invalidate();
//			}
//
//			@Override
//			public void onFinish() {
//				_progressElapsedCounter.setText( generateTimeString( _elapsedTimer.getMillis() ) );
//				_progressElapsedCounter.invalidate();
//			}
//		}.start();
//	}

//	private String generateTimeString( final long millis ) {
//		try {
//			final long elapsed = Instant.now().getMillis() - millis;
//			final DateTimeFormatterBuilder timeFormatter = new DateTimeFormatterBuilder();
//			if (elapsed > TimeUnit.HOURS.toMillis( 1 )) {
//				timeFormatter.appendHourOfDay( 2 ).appendLiteral( "h " );
//			}
//			if (elapsed > TimeUnit.MINUTES.toMillis( 1 )) {
//				timeFormatter.appendMinuteOfHour( 2 ).appendLiteral( "m " ).appendSecondOfMinute( 2 ).appendLiteral( "s" );
//			} else timeFormatter.appendSecondOfMinute( 2 ).appendLiteral( "s" );
//			return timeFormatter.toFormatter().print( new Instant( elapsed ) );
//		} catch (final RuntimeException rtex) {
//			return "0m 00s";
//		}
//	}
}
