package org.dimensinfin.android.mvc.activity;

import android.content.Context;
import android.os.Bundle;
import android.os.CountDownTimer;
import android.view.ContextMenu;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.ListView;
import android.widget.TextView;

import androidx.annotation.Nullable;

import org.dimensinfin.android.mvc.R;
import org.dimensinfin.android.mvc.controller.AndroidController;
import org.dimensinfin.android.mvc.core.AppCompatibilityUtils;
import org.dimensinfin.android.mvc.datasource.DataSourceAdapter;
import org.dimensinfin.android.mvc.datasource.DataSourceManager;
import org.dimensinfin.android.mvc.datasource.HeaderDataSourceAdapter;
import org.dimensinfin.android.mvc.datasource.IDataSource;
import org.dimensinfin.android.mvc.exception.ExceptionRenderGenerator;
import org.dimensinfin.android.mvc.interfaces.IMenuActionTarget;
import org.joda.time.Instant;
import org.joda.time.format.DateTimeFormatterBuilder;

import java.util.Objects;
import java.util.concurrent.TimeUnit;

/**
 * @author Adam Antinoo
 * @since 1.0.0
 */
public abstract class MVCPagerFragment extends MVCFragment {
	/**
	 * This is the reference to the root view generated by the inflation of the fragment's layout.
	 */
	protected ViewGroup _container;

	// - U I    F I E L D S
	/**
	 * The view that handles the non scrolling header. It accepts a list of Views but has no scroll capabilities.
	 */
	protected ViewGroup _headerContainer;
	/** The adapter to transform the model list to the view contents for the header section or a page. */
	private HeaderDataSourceAdapter headerDataSectionContainer;
	/**
	 * Evolved adapter to connect the source of data in the form of a <b>AndroidController</b> list to the
	 * <code>ListView</code> that contains the displayed render.
	 */
	private DataSourceAdapter _adapter;
	/**
	 * The view that represent the list view and the space managed though the adapter.
	 */
	private ListView _dataSectionContainer;
	/**
	 * The UI graphical element that defines the loading progress spinner layout.
	 */
	private ViewGroup _progressLayout;
	/**
	 * This is a text field defined inside the loading progress spinner that will show the time elapsed waiting for the
	 * completion of the loading process.
	 */
	private TextView _progressElapsedCounter;
	private Exception lastException;

	// - A C C E P T A N C E
	public ViewGroup accessHeaderContainer() {
		return this._headerContainer;
	}

	public ListView accessDataSectionContainer() {
		return this._dataSectionContainer;
	}

	public Exception getLastException() {
		return this.lastException;
	}
	// - F R A G M E N T   L I F E C Y C L E

	@Nullable
	@Override
	public Context getContext() {
		return this.getActivityContext();
	}

	/**
	 * During the creation process we connect the local fields to the UI graphical objects defined by the layout. We use a
	 * generic layout that defines the two items that compose all the displays for the MVC fragments. The <b>Header</b>
	 * ViewGroup container, the <b>Data Section</b> implemented by a ListView and the loading progress indicator that will
	 * be present on the DataSection display are while the model is generated and transformed into the View list. At that
	 * point the progress will be removed to show the view list for this time instant model.
	 *
	 * The method has two sections. The first section will find and reference the ui graphical elements where to render
	 * the data while the second section will instantiate and initialize the application specific code to generate the
	 * models for this fragment instance.
	 *
	 * @param inflater           <code>LayoutInflater</code> received from the context to create the layout from the XML
	 *                           definition file.
	 * @param container          container where this layout is displayed.
	 * @param savedInstanceState if we are recovering the layout from a task switch this is the previous saved state of
	 *                           the fragment when the application was switched out of focus.
	 * @return the view that represents the fragment ui layout structure.
	 */
	@Override
	public View onCreateView( final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState ) {
		logger.info(">> [MVCPagerFragment.onCreateView]");
		super.onCreateView(inflater, container, savedInstanceState);
		// TODO analyze what is returned by the savedInstanceState when recovering the application. That will help to recover the
		// functional state of the application.
		// - S E C T I O N   1. Where we get access to the UI elements.
		_container = (ViewGroup) inflater.inflate(R.layout.fragment_base, container, false);
		_headerContainer = Objects.requireNonNull(_container.findViewById(R.id.headerContainer));
		_dataSectionContainer = Objects.requireNonNull(_container.findViewById(R.id.listContainer));
		_progressLayout = Objects.requireNonNull(_container.findViewById(R.id.progressLayout));
		_progressElapsedCounter = Objects.requireNonNull(_container.findViewById(R.id.progressCounter));

		// Set the visual state of all items.
		_progressLayout.setVisibility(View.VISIBLE);
		_dataSectionContainer.setVisibility(View.VISIBLE);
		_progressElapsedCounter.setVisibility(View.VISIBLE);
		// Prepare the structures for the context menu.
		// TODO Check if the menus can be tied to the Parts independently and not to the whole Header.
		//			this.registerForContextMenu(_headerContainer);
		this.registerForContextMenu(_dataSectionContainer);

		// - S E C T I O N   2. Where we setup the data sources for the adapters. Only include no timing operations.
		try {
			// Install the adapter before any data request or model generation.
			final IDataSource ds = DataSourceManager.registerDataSource(this.createDS());
			this._adapter = new DataSourceAdapter(this, ds);
			Objects.requireNonNull(this._adapter);
			logger.info("-- [MVCPagerFragment.DS Initialisation]> Adapter set: {}", _adapter.toString());
			_dataSectionContainer.setAdapter(_adapter);
			this.headerDataSectionContainer = new HeaderDataSourceAdapter(this, ds).setHeaderContainer(this._headerContainer);
			Objects.requireNonNull(this.headerDataSectionContainer);

			// - S E C T I O N   3. Post the tak to generate the header contents to be rendered.
			AppCompatibilityUtils.backgroundExecutor.submit(() -> {
//			handler.post(() -> {
				logger.info("-- [MVCPagerFragment.DS Initialisation]");
				this._adapter.collaborateData(); // Call the ds to generate the root contents.
				this.headerDataSectionContainer.collaborateData();
			});
		} catch (RuntimeException rtex) {
			logger.info("RX [MVCPagerFragment.onCreateView]> Intercepted exception: {}", rtex.getMessage());
			this.lastException = rtex;
			this.showException(rtex); // Show any exception data on the empty page.
		}
		logger.info("<< [MVCPagerFragment.onCreateView]");
		return _container;
	}

	@Override
	public void onViewStateRestored( Bundle savedInstanceState ) {
		// restore the variant name.
		if (null != savedInstanceState)
			setVariant(savedInstanceState.getString(MVCMultiPageActivity.EMVCExtras.EXTRA_VARIANT.name()));
		super.onViewStateRestored(savedInstanceState);
	}

	/**
	 * At this point on the Fragment life cycle we are sure that the fragment is already constructed and that the flow is
	 * ready to get and process the model data. The model data is going to be feed directly to the rendering layout while
	 * it is being generated so the experience is more close to real time data presentation. INstead waiting for all the
	 * model generation and model transformation processed to complete we will be streaming the data since the first
	 * moment we have something to show.
	 */
	@Override
	public void onStart() {
		logger.info(">> [MVCPagerFragment.onStart]");
		super.onStart();
		if (null != this._adapter) { // Cehck that view creation complete successfully.
			// Start counting the elapsed time while we generate and load the  model.
			this.initializeProgressIndicator();
			// We use another thread to perform the data source generation that is a long time action.
			AppCompatibilityUtils.backgroundExecutor.submit(() -> {
				logger.info("-- [MVCPagerFragment.Render data section]");
//				handler.post(() -> { // After the model is created used the UI thread to render the collaboration to view.
				this.getActivityContext().runOnUiThread(() -> {
					this._adapter.notifyDataSetChanged();
					this.headerDataSectionContainer.notifyDataSetChanged();
					this.hideProgressIndicator(); // Hide the waiting indicator after the model is generated and the view populated.
				});
			});
		}
		logger.info("<< [MVCPagerFragment.onStart]");
	}

	@Override
	public void onSaveInstanceState( final Bundle outState ) {
		super.onSaveInstanceState(outState);
		// Save the variant assigned to this fragment instance.
		outState.putString(MVCMultiPageActivity.EMVCExtras.EXTRA_VARIANT.name(), getVariant());
	}

	@Override
	public void onCreateContextMenu( final ContextMenu menu, final View view, final ContextMenu.ContextMenuInfo menuInfo ) {
		logger.info(">> [MVCPagerFragment.onCreateContextMenu]");
		// REFACTOR If we call the super then the fragment's parent context gets called. So the listcallback and the Activity
		// have not to be the same
		//			super.onCreateContextMenu(menu, view, menuInfo);
		// Check parameters to detect the item selected for menu target.
		//		if (view == _headerContainer) {
		//			// Check if this fragment has the callback configured
		//			final IAndroidAndroidController part = _headerContents.firstElement();
		//			if (part instanceof IMenuActionTarget) {
		//				((IMenuActionTarget) part).onCreateContextMenu(menu, view, menuInfo);
		//			}
		//		}
		//		if (view == _dataSectionContainer) {
		// Now header and data section ave the same functionality.
		// Get the tag assigned to the selected view and if implements the callback interface send it the message.
		final AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) menuInfo;
		// Check if the selected item is suitable for menu and select it depending on item part class.
		AndroidController part = (AndroidController) info.targetView.getTag();
		if (part instanceof IMenuActionTarget) {
			((IMenuActionTarget) part).onCreateContextMenu(menu, view, menuInfo);
		}
		//		}
		logger.info("<< [MVCPagerFragment.onCreateContextMenu]"); //$NON-NLS-1$
	}

	// - CONTEXTUAL MENU FOR THE HEADER
	@Override
	public boolean onContextItemSelected( final MenuItem item ) {
		logger.info(">> ManufactureContextFragment.onContextItemSelected");
		final AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
		final int menuItemIndex = item.getItemId();
		final AndroidController part = (AndroidController) info.targetView.getTag();
		if (part instanceof IMenuActionTarget)
			return ((IMenuActionTarget) part).onContextItemSelected(item);
		else
			return true;
	}

	// - H E A D E R   M A N A G E M E N T   S E C T I O N

	protected void showException( final Exception exception ) {
		// Hide standard elements.
		this._headerContainer.setVisibility(View.GONE);
		this._dataSectionContainer.setVisibility(View.GONE);
		final ViewGroup exceptionContainer = _container.findViewById(R.id.exceptionContainer);
		exceptionContainer.removeAllViews();
		exceptionContainer.addView(new ExceptionRenderGenerator.Builder(exception)
				                           .withContext(this.getContext())
				                           .withFactory(this.getFactory())
				                           .build().getView());
		exceptionContainer.setVisibility(View.VISIBLE);
	}

	private void hideProgressIndicator() {
		_progressLayout.setVisibility(View.GONE);
		_dataSectionContainer.setVisibility(View.VISIBLE);
		_progressElapsedCounter.setVisibility(View.GONE);
	}

	// - U T I L I T I E S
	private void initializeProgressIndicator() {
		_progressElapsedCounter = Objects.requireNonNull(_container.findViewById(R.id.progressCounter));
		final Instant _elapsedTimer = Instant.now();
		new CountDownTimer(TimeUnit.DAYS.toMillis(1), TimeUnit.MILLISECONDS.toMillis(10)) {
			@Override
			public void onTick( final long millisUntilFinished ) {
				_progressElapsedCounter.setText(generateTimeString(_elapsedTimer.getMillis()));
				_progressElapsedCounter.invalidate();
			}

			@Override
			public void onFinish() {
				_progressElapsedCounter.setText(generateTimeString(_elapsedTimer.getMillis()));
				_progressElapsedCounter.invalidate();
			}
		}.start();
	}

	private String generateTimeString( final long millis ) {
		try {
			final long elapsed = Instant.now().getMillis() - millis;
			final DateTimeFormatterBuilder timeFormatter = new DateTimeFormatterBuilder();
			if (elapsed > TimeUnit.HOURS.toMillis(1)) {
				timeFormatter.appendHourOfDay(2).appendLiteral("h ");
			}
			if (elapsed > TimeUnit.MINUTES.toMillis(1)) {
				timeFormatter.appendMinuteOfHour(2).appendLiteral("m ").appendSecondOfMinute(2).appendLiteral("s");
			} else timeFormatter.appendSecondOfMinute(2).appendLiteral("s");
			return timeFormatter.toFormatter().print(new Instant(elapsed));
		} catch (final RuntimeException rtex) {
			return "0m 00s";
		}
	}
}
