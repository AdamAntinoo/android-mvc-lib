//  PROJECT:     Android.MVC (A.MVC)
//  AUTHORS:     Adam Antinoo - adamantinoo.git@gmail.com
//  COPYRIGHT:   (c) 2013-2018 by Dimensinfin Industries, all rights reserved.
//  ENVIRONMENT: Android API16.
//  DESCRIPTION: Library that defines a generic Model View Controller core classes to be used
//               on Android projects. Defines the Part factory and the Part core methods to manage
//               a generic converter from a Graph Model to a hierarchycal Part model that finally will
//               be converted to a Part list to be used on a BaseAdapter tied to a ListView.
package org.dimensinfin.android.mvc.activity;

import android.app.Activity;
import androidx.fragment.app.Fragment;
import android.os.Bundle;
import android.view.ContextMenu;
import android.view.LayoutInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import org.dimensinfin.android.mvc.R;
import org.dimensinfin.android.mvc.core.AbstractAndroidPart;
import org.dimensinfin.android.mvc.core.AbstractExpandablePart;
import org.dimensinfin.android.mvc.core.AbstractPart;
import org.dimensinfin.android.mvc.core.AbstractRender;
import org.dimensinfin.android.mvc.core.RootPart;
import org.dimensinfin.android.mvc.datasource.DataSourceAdapterv3;
import org.dimensinfin.android.mvc.datasource.DataSourceLocator;
import org.dimensinfin.android.mvc.datasource.DataSourceManagerv3;
import org.dimensinfin.android.mvc.datasource.MVCDataSource;
import org.dimensinfin.android.mvc.interfaces.IAndroidPart;
import org.dimensinfin.android.mvc.interfaces.IPartsDataSource;
import org.dimensinfin.android.mvc.interfaces.IMenuActionTarget;
import org.dimensinfin.android.mvc.interfaces.IPart;
import org.dimensinfin.android.mvc.interfaces.IPartFactory;
import org.dimensinfin.android.mvc.interfaces.IRender;
import org.dimensinfin.core.interfaces.ICollaboration;
import org.dimensinfin.core.interfaces.IExpandable;
import org.dimensinfin.core.model.RootNode;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.Vector;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author Adam Antinoo
 * @since 1.0.0
 */
// - CLASS IMPLEMENTATION ...................................................................................
// REFACTOR Used this dependency just to maintain more code compatible with the new model.
public abstract class AbstractPagerFragment extends Fragment {
	// - S T A T I C - S E C T I O N ..........................................................................
	protected static Logger logger = LoggerFactory.getLogger("AbstractPagerFragment");
	public static final ExecutorService _uiExecutor = Executors.newFixedThreadPool(1);

	// - F I E L D - S E C T I O N ............................................................................
	/**
	 * The variant is an optional field that should be set by the developer. Because it will choose not to fill it should
	 * have a valid default value.
	 */
	private String _variant = "-DEFAULT-";
	/** Copy of the extras bundle received by the Activity. */
	private Bundle _extras = new Bundle();
	/**
	 * The library will require access to a valid application context at any time. Usually the application is not
	 * connected to the Fragment until the fragment is going to be used and then the life cycle is started. But if the
	 * developed likes to use fragments not connected to real Activities we should be sure we can still have access to a
	 * valid context.
	 */
	private Activity _appContext;
	/** Factory that will generate the specific <b>Parts</b> for this Fragment/Activity/Application. */
	private IPartFactory _factory = null;
	/** This flag will help to detect when the creation process fails because of a rutime problem. */
	private boolean _properlyInitialized = true;
	/** List of model elements that should be converted to views and inserted on the Header ui container. */
	private List<ICollaboration> _headersource = null;
	/**
	 * Instance for a dynamic model generator. The model can change after creation by user interactions through the
	 * rendered views and parts.
	 */
	private IPartsDataSource _datasource = null;
	/**
	 * Evolved adapter to connect the source of data in the form of a <b>Part</b> list to the <code>ListView</code> that
	 * contains the displayed render.
	 */
	private DataSourceAdapterv3 _adapter = null;

	// - U I    F I E L D S
	/** This is the reference to the view generated by the inflation of the fragment's layout. */
	private ViewGroup _container = null;
	/** The view that handles the non scrolling header. It accepts a list of Views but has no scroll capabilities. */
	private ViewGroup _headerContainer = null;
	/** The view that represent the list view and the space managed though the adapter. */
	private ListView _dataSectionContainer = null;
	/** The UI graphical element that defines the loading progress spinner layout. */
	private ViewGroup _progressLayout = null;
	/**
	 * This is a text field defined inside the loading progress spinner that will show the time elapsed waiting for the
	 * completion of the loading process.
	 */
	private TextView _progressElapsedCounter = null;


	// TODO REFACTOR Set back to private after the PagerFragment is removed
	private final Vector<IAndroidPart> _headerContents = new Vector<IAndroidPart>();
//	private IModelGenerator _generator = null;


	private IMenuActionTarget _listCallback = null;

	// - C O N S T R U C T O R - S E C T I O N ................................................................

	// - M E T H O D - S E C T I O N ..........................................................................
	public void setListCallback( final IMenuActionTarget callback ) {
		if (null != callback) {
			_listCallback = callback;
		}
	}
	//--- G E T T E R S   &   S E T T E R S

	/**
	 * Sets the variant code to differentiate this instance form any other Fragment instances. This field should be set on
	 * the instantiation process of the Fragment and also should be recovered from persistence when the fragment is
	 * reconstructed.
	 * @return the variant name assigned to this fragment instance.
	 */
	public String getVariant() {
		return _variant;
	}

	/**
	 * Sets the variant name. Variant names should come from a limited list of strings, usually implemented as an
	 * enumerated and that is set for each fragment instance that should have any differentiation. The value is restored
	 * on fragment reconstruction and can help to add specific and differential funtionalities.
	 * @param selectedVariant the new name to assign to this fragment instance.
	 * @return
	 */
	public AbstractPagerFragment setVariant( final String selectedVariant ) {
		_variant = selectedVariant;
		return this;
	}

	/**
	 * Gets a reference to the extras received by the Activity. They can come from the intent of from the persistence
	 * stored data upon Application reactivation.
	 * @return extras bundle.
	 */
	public Bundle getExtras() {
		return _extras;
	}

	/**
	 * Sets the extras to be associated to the Fragment. This is usually automatically setup by the Activity but the
	 * developer can change the set of extras at any time. Contents are transparent to the library and are nor user by
	 * it.
	 * @param extras new bundle of extrax to be tied to this Fragment instance.
	 * @return this instance to allow for functional constructive statements.
	 */
	public AbstractPagerFragment setExtras( final Bundle extras ) {
		_extras = extras;
		return this;
	}

	public Activity getAppContext() {
		final Activity act = getActivity();
		if (null == act)
			if (null == _appContext)
				throw new RuntimeException("RTEX [AbstractPagerFragment.getAppContext] There is no Context " +
						"accesible. Application unexpected error.");
			else return _appContext;
		else return act;
	}

	/**
	 * During initialization of the Fragment we install an alternate way to access the Activity. By using this method we
	 * make sure the context is ever accesible during the use of the Fragment, be it tied to an Activity or not.
	 * @param newcontext the Activity where this Fragment is connected.
	 * @return this instance to allow for functional constructive statements.
	 */
	public AbstractPagerFragment setAppContext( final Activity newcontext ) {
		this._appContext = newcontext;
		return this;
	}

	/**
	 * Returns the <b>PartFactory</b> associated with this Fragment instance. If the factory is still undefined then the
	 * method calls the creation method to get a fresh instance.
	 * @return
	 */
	public IPartFactory getFactory() {
		// Check if we have already a factory.
		if (null == _factory) {
			_factory = this.createFactory();
		}
		return _factory;
	}

	//--- ABSTRACT METHODS TO BE IMPLEMENTED BY APP

	/**
	 * This method should be implemented by all the application Fragments to set the <b>PartFactory</b> that will be used
	 * during the model transformation processing to generate the <b>Parts</b> of the model to be used on this Fragment.
	 */
	public abstract IPartFactory createFactory();

	/**
	 * Gets the text to set set at the subtitle slot on the <b>ActionBar</b>. This should be implemented by each new
	 * Fragment.
	 * @return subtitle string.
	 */
	public abstract String getSubtitle();

	/**
	 * Gets the text to set set at the title slot on the <b>ActionBar</b>. This should be implemented by each new
	 * Fragment.
	 * @return title string.
	 */
	public abstract String getTitle();

	/**
	 * This method that should be implemented at every fragment is responsible to generate a list of model data that
	 * should be transformed into <code>Views</code> to be rendered on the Header container.
	 * @return a <code>List</code> of model instances that should be converted to Parts and then to Views to be stored on
	 * the Header container and rendered. This is a simple list and not a so complex model as the <code>IPartsDataSource</code>
	 * used for the DataSection contents.
	 */
	protected abstract List<ICollaboration> registerHeaderSource();

	/**
	 * This method that should be implemented at every fragment is responsible to instantiate, identify and initialize a
	 * <code>@link{IPartsDataSource}</code> that is the class code that generates the model structures, be them list, hierarchy
	 * or graphs.
	 * @return an <code>IPartsDataSource</code> instance that is ready to generate the model contents.
	 */
	protected abstract IPartsDataSource registerDataSource();


	//--- F R A G M E N T   L I F E C Y C L E

	/**
	 * During the creation process we connect the local fields to the UI graphical objects defined by the layout. We use a
	 * generic layout that defines the 4 items that compose all the displays for the MVC fragments. The <b>Header</b>
	 * ViewGroup container, the <b>DataSection</b> implemented by a ListView and the loading progress indicator that will
	 * be present on the DataSection display are while the model is generated and transformed into the View list. At that
	 * point the progress will be removed to show the view list for this time instant model.
	 * <p>
	 * The method has two sections. The first section will find and reference the ui graphical elements where to render
	 * the data while the second section will instantiate and initialize the application specific code to generate the
	 * specific models for this fragment instance.
	 * @param inflater           <code>LayoutInflater</code> received from the context to create the layout from the XML
	 *                           definition file.
	 * @param container          container where this layout is displayed.
	 * @param savedInstanceState if we are recovering the layout from a task switch this is the previous saved state of
	 *                           the fragment when the application was switched out of focus.
	 * @return the view that represents the fragment ui layout structure.
	 */
	@Override
	public View onCreateView( final LayoutInflater inflater, final ViewGroup container, final Bundle savedInstanceState ) {
		logger.info(">> [AbstractPagerFragment.onCreateView]");
		final View theView = super.onCreateView(inflater, container, savedInstanceState);
		// TODO analyze what is returned by the savedInstanceState when recovering the application. That will help to recover the
		// functional state of the application.
		// Section where we get access to the UI elements.
		try {
			_container = (ViewGroup) inflater.inflate(R.layout.fragment_base, container, false);
			_headerContainer = (ViewGroup) _container.findViewById(R.id.headerContainer);
			_dataSectionContainer = (ListView) _container.findViewById(R.id.listContainer);
			_progressLayout = (ViewGroup) _container.findViewById(R.id.progressLayout);
			_progressElapsedCounter = (TextView) _container.findViewById(R.id.progressCounter);

			// Set the visual state of all items.
			_progressLayout.setVisibility(View.GONE);
			_dataSectionContainer.setVisibility(View.VISIBLE);
			_progressElapsedCounter.setVisibility(View.GONE);
			// Prepare the structures for the context menu.
			// TODO Check if the menus can be tied to the Parts independently and not to the whole Header.
			//			this.registerForContextMenu(_headerContainer);
			this.registerForContextMenu(_dataSectionContainer);
		} catch (final RuntimeException rtex) {
			AbstractPagerFragment.logger.error("RTEX [AbstractPagerFragment.onCreateView]> {}.", rtex.getMessage());
			rtex.printStackTrace();
			// Instead blocking the application drop a toast and move to the First Activity.
			Toast.makeText(this.getAppContext()
					, "RTEX [AbstractPagerFragment.onCreateView]> " + rtex.getMessage()
					, Toast.LENGTH_LONG).show();
			// Use a flag to signal that this Fragment is not properly initialized to no other methods should be called.
			_properlyInitialized = false;
		}

		// Section where we setup the data sources for the adapters. Only include no timing operations.
		try {
			// Entry point to generate the Header model.
//			_headersource = this.registerHeaderSource();
			// Entry point to generate the DataSection model.
			_datasource = DataSourceManagerv3.registerDataSource(this.registerDataSource());
			// Check that the datasource is a valid data source.
			if (null == _datasource) _datasource = new EmptyDataSource(new DataSourceLocator().addIdentifier("EMPTY")
					, getVariant(), getFactory(), getExtras());
			// Install the adapter before any data request or model generation.
			_adapter = new DataSourceAdapterv3(this, _datasource);
			_dataSectionContainer.setAdapter(_adapter);
		} catch (final RuntimeException rtex) {
			AbstractPagerFragment.logger.error("RTEX [AbstractPagerFragment.onCreateView]> {}.", rtex.getMessage());
			rtex.printStackTrace();
			// Instead blocking the application drop a toast and move to the First Activity.
			Toast.makeText(this.getAppContext()
					, "RTEX [AbstractPagerFragment.onCreateView]> " + rtex.getMessage()
					, Toast.LENGTH_LONG).show();
			_properlyInitialized = false;
		}
		AbstractPagerFragment.logger.info("<< [AbstractPagerFragment.onCreateView]");
		return _container;
	}
	//[03]

	/**
	 * At this point on the Fragment life cycle we are sure that the fragment is already constructed and that the flow is
	 * ready to get and process the model data. The model data is going to be feed directly to the rendering layout while
	 * it is being generated so the experience is more close to real time data presentation. INstead waiting for all the
	 * model generation and model transformation processed to complete we will be streaming the data since the first
	 * moment we have something to show.
	 */
	@Override
	public void onStart() {
		AbstractPagerFragment.logger.info(">> [AbstractPagerFragment.onStart]");
		super.onStart();
		try {
			// The first action is to add a progress indicator to the contents.
			// This way once we finish the configuration the display will refresh with the spinner on it.
			// We remove the spinner from the display when the model generation ends.
			_datasource.startOnLoadProcess();
			getAppContext().runOnUiThread(() -> {
				_adapter.notifyDataSetChanged();
			});
			// Create the hierarchy structure to be used on the Header. We have the model list and we should convert it to a view list.
			AbstractPagerFragment._uiExecutor.submit(() -> {
				// Entry point to generate the Header model.
				_headersource = this.registerHeaderSource();
				generateHeaderContents(_headersource);
			});
			// Create the hierarchy structure to be used on the Adapter for the DataSection.
			// Do this on background so we can update the interface on real time.
			AbstractPagerFragment._uiExecutor.submit(() -> {
				_datasource.collaborate2Model();
				getAppContext().runOnUiThread(() -> {
					_adapter.notifyDataSetChanged();
				});
			});
		} catch (final RuntimeException rtex) {
			AbstractPagerFragment.logger.error("RTEX [AbstractPagerFragment.onStart]> {}.", rtex.getMessage());
			rtex.printStackTrace();
			Toast.makeText(this.getAppContext()
					, "RTEX [AbstractPagerFragment.onStart]> " + rtex.getMessage()
					, Toast.LENGTH_LONG).show();
		}
		AbstractPagerFragment.logger.info("<< [AbstractPagerFragment.onStart]");
	}

	@Override
	public void onViewStateRestored( Bundle savedInstanceState ) {
		// restore the variant name.
		if (null != savedInstanceState)
			setVariant(savedInstanceState.getString(AbstractPagerActivity.EExtrasMVC.EXTRA_VARIANT.name()));
		super.onViewStateRestored(savedInstanceState);
	}

	@Override
	public void onSaveInstanceState( Bundle outState ) {
		super.onSaveInstanceState(outState);
		// Save the variant assigned to this fragment instance.
		outState.putString(AbstractPagerActivity.EExtrasMVC.EXTRA_VARIANT.name(), getVariant());
	}

	//--- H E A D E R   M A N A G E M E N T   S E C T I O N

	/**
	 * This method is the way to transform the list of model data prepared for the Header to end on a list of Views inside
	 * the Header container. We follow a similar mechanics that for the DataSection ListView but instead keeping the
	 * intermediate Part model we go directly to the View output by the <b>Render</b> instance.
	 * <p>
	 * The use of a fake <code>@link{RootNode}</code> allows to also support model elements that have contents that should
	 * be rendered when expanded. Even the header contents are limited in interaction we can have expand/collapse
	 * functionalities to calculate the final list of Views to render.
	 */
	protected void generateHeaderContents( final List<ICollaboration> headerData ) {
		logger.info(">> [AbstractPagerFragment.generateHeaderContents]");
		try {
			// Create a fake root node where to connect the list. This wil
			RootNode headerModel = new RootNode();
			for (ICollaboration node : headerData) {
				headerModel.addChild(node);
			}

			// Do the same operations as in the body contents. Create a root, add to it the model elements and then
			// recursively generate the Part list.
			final RootPart partModelRoot = new RootPart(headerModel, getFactory());
			partModelRoot.refreshChildren();
			ArrayList<IAndroidPart> headerParts = new ArrayList<IAndroidPart>();
			// Select for the body contents only the viewable Parts from the Part model. Make it a list.
			partModelRoot.collaborate2View(headerParts);

			// Now do the old functionality by copying each of the resulting parts to the Header container.
			getAppContext().runOnUiThread(() -> {
				_headerContainer.removeAllViews();
				for (IPart part : headerParts) {
					if (part instanceof IAndroidPart) addView2Header((IAndroidPart) part);
				}
			});
		} catch (RuntimeException rtex) {
			rtex.printStackTrace();
		}
		logger.info("<< [AbstractPagerFragment.generateHeaderContents]");
	}

	/**
	 * This method extract the view from the parameter part and generates the final View element that is able to be
	 * inserted on the ui ViewGroup container.
	 * @param target the Part to render to a View.
	 */
	private void addView2Header( final IAndroidPart target ) {
		logger.info(">> [AbstractPagerFragment.addView2Header]");
		try {
			final IRender holder = target.getRenderer(this.getAppContext());
			holder.initializeViews();
			holder.updateContent();
			final View hv = holder.getView();
			_headerContainer.addView(hv);
			// Add the connection to the click listener
			if (target instanceof OnClickListener) {
				hv.setClickable(true);
				hv.setOnClickListener((OnClickListener) target);
			}
			_headerContainer.setVisibility(View.VISIBLE);
		} catch (final RuntimeException rtex) {
			logger.info("RTEX [AbstractPagerFragment.addView2Header]> Problem generating view for: " + target.getClass().getCanonicalName());
			logger.info("RTEX [AbstractPagerFragment.addView2Header]> RuntimeException. " + rtex.getMessage());
			rtex.printStackTrace();
			Toast.makeText(this.getAppContext()
					, "RTEX [AbstractPagerFragment.addView2Header]> RuntimeException. " + rtex.getMessage()
					, Toast.LENGTH_LONG).show();
		}
		logger.info("<< AbstractPagerFragment.addView2Header");
	}

	//--- CONTEXTUAL MENU FOR THE HEADER
	@Override
	public boolean onContextItemSelected( final MenuItem item ) {
		logger.info(">> ManufactureContextFragment.onContextItemSelected");
		final AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
		final int menuItemIndex = item.getItemId();
		final AbstractAndroidPart part = (AbstractAndroidPart) info.targetView.getTag();
		if (part instanceof IMenuActionTarget)
			return ((IMenuActionTarget) part).onContextItemSelected(item);
		else
			return true;
	}

	@Override
	public void onCreateContextMenu( final ContextMenu menu, final View view, final ContextMenu.ContextMenuInfo menuInfo ) {
		logger.info(">> [AbstractPagerFragment.onCreateContextMenu]");
		// REFACTOR If we call the super then the fragment's parent activity gets called. So the listcallback and the Activity
		// have not to be the same
		//			super.onCreateContextMenu(menu, view, menuInfo);
		// Check parameters to detect the item selected for menu target.
		//		if (view == _headerContainer) {
		//			// Check if this fragment has the callback configured
		//			final IAndroidPart part = _headerContents.firstElement();
		//			if (part instanceof IMenuActionTarget) {
		//				((IMenuActionTarget) part).onCreateContextMenu(menu, view, menuInfo);
		//			}
		//		}
		//		if (view == _dataSectionContainer) {
		// Now header and data section ave the same functionality.
		// Get the tag assigned to the selected view and if implements the callback interface send it the message.
		final AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) menuInfo;
		// Check if the selected item is suitable for menu and select it depending on item part class.
		AbstractAndroidPart part = (AbstractAndroidPart) info.targetView.getTag();
		if (part instanceof IMenuActionTarget) {
			((IMenuActionTarget) part).onCreateContextMenu(menu, view, menuInfo);
		}
		//		}
		logger.info("<< [AbstractPagerFragment.onCreateContextMenu]"); //$NON-NLS-1$
	}

	//- CLASS IMPLEMENTATION ...................................................................................
	public static class EmptyDataSource extends MVCDataSource {
		public EmptyDataSource( DataSourceLocator locator, String variant, IPartFactory factory, Bundle extras ) {
			super(locator, variant, factory, extras);
		}

		@Override
		public void collaborate2Model() {
			// Create an empty list of items. This can be done by setting a model that if not rendered when empty.
			this.addModelContents(new EmptyNotVisibleNode());
		}
	}

	public static class EmptyNotVisibleNode implements IExpandable {
		public EmptyNotVisibleNode() {
			super();
			this.setRenderWhenEmpty(false);
		}

		@Override
		public boolean collapse() {
			return false;
		}

		@Override
		public boolean expand() {
			return false;
		}

		@Override
		public boolean isEmpty() {
			return true;
		}

		@Override
		public boolean isExpanded() {
			return false;
		}

		@Override
		public boolean isRenderWhenEmpty() {
			return false;
		}

		@Override
		public IExpandable setRenderWhenEmpty( final boolean renderWhenEmpty ) {
			return this;
		}

		@Override
		public List<ICollaboration> collaborate2Model( final String variation ) {
			return new ArrayList<>();
		}

		@Override
		public int compareTo( final Object o ) {
			return 0;
		}
	}

	public static class EmptyPart extends AbstractExpandablePart {

		public EmptyPart( final ICollaboration model ) {
			super(model);
		}

		@Override
		public long getModelId() {
			return 0;
		}

		@Override
		public AbstractRender selectRenderer() {
			return new EmptyRender(this, this.getActivity());
		}

		@Override
		public boolean runDependencies() {
			return false;
		}
		@Override
		public boolean isEmpty() {
			return true;
		}

		@Override
		public List<IPart> runPolicies( final List<IPart> targets ) {
			return targets;
		}

	}

	public static class EmptyRender extends AbstractRender {

		public EmptyRender( final AbstractPart newPart, final Activity context ) {
			super(newPart, context);
		}

		@Override
		public void initializeViews() {

		}

		@Override
		public void updateContent() {

		}

		@Override
		public int accessLayoutReference() {
			return R.layout.separatorgreenline;
		}
	}
}

// - UNUSED CODE ............................................................................................
